# Модели данных

1. Теория моделей
2. Менеджер моделей Model
  1. Общее описание
  2. Выборки (get methods)
  3. Добавление (add methods)
  4. Изменение (update methods)
  5. Удаление (delete methods)
  6. Импорт (delete methods)
  7. Связи (link methods)
    1. Теория и типы связей
    2. Генерация связей по базе данных
    3. Добавление своих связей
  3. Объекты сущности Entity
    1. Типы данных
    2. Getters
4. Объект коллекции Collection
5. [Фильтры](#5)
    1. [Теория фильтрации](#5_1)
    2. [Значения по-умолчанию](#5_2)
    3. [Каскад данных при фильтрации](#5_3)
    4. [Как добавить свои фильтры в модель](#5_4)
    5. [Как отфильтровать входные данные](#5_5)
    6. [Как отфильтровать отдельное поле (filterValue)](#5_6)
    7. [Как запретить фильтрацию](#5_7)
    8. [Как работает фильтрация (вид изнутри)](#5_8)
    9. [Фильтры, которые прописываются автоматически](#5_9)
    10. [Список фильтров](#5_10)
6. [Валидаторы](#6)
    1. [Теория валидации](#6_1)
    2. [Как добавить свои валидаторы в модель?](#6_2)
    3. [Как проверить отдельное поле (validateValue)](#6_3)
    4. [Схема инициализации работы валидатора](#6_4)
7. [Объект результата выполнения операции](#7)
8. [Объекты условий Cond](#8)
    1. [Общее описание](#8_1)

# <a name="1"/> Chapter 1. Теория моделей

## <a name="1_1"/> Chapter 1.1. Что это такое?

* ЭТО НЕ ORM, как его понимают программисты PHP :)
* ЭТО ORM, так как иммет связи;
* Тут нет и не будет ActiveRecord;
* Основной принцип - договоренности и условности;
* Жестка формальность наименований и полей БД;
* Упрощенные объектные связи;
* Упрощенное управление данными в БД;
* Выделение сущностей и действий над ними.

Так что же это такое?! Модели - базируются на договоренностях наименования таблиц, полей и ключей в базе данных. В моделях мы выделяем сущности (Entity) и связи между сущьностями. Модель позволяет управлять данными в базе.

## <a name="1_2"/> Chapter 1.2. Цели моделей?

При проектировании моделей преследовалась цель дать инструмент для работы с базой данных для пользователей разного уровня квалификации:

* **Начинающий** - знает основы, может пользоваться только интерфейсом (тем что уже есть), не может сильно накосячить;
* **Обычный уровень** - понимает как работает, как работают связи и основные части системы, может строить сложные выборки и обработки, не может сильно накосячить;
* **Гуру** - понимает архитектуру, может дописывать плагины, модифицировать сами модели, может очень сильно накосячить;

От этих трех целей строится вся идея моделей.

### Пример

Есть комманда разработчиков разного уровня:

* Женя - разработчик, только пришел в компанию;
* Петя - разработчик, работает в компании долго, примерно знает как все устроено;
* Вася - проектирует все новые разработки.

Жене дали задание сделать сложный раздел. Он накидывает базу данных по всем правилам.
Так же не забывает, прописать все фильтры и валидаторы. Система моделей автоматически генерит ему работающий CRUD-код.
Женя его использует и незадумывается над правильностью этого кода. Но, Жене нужно сделать сложную выборку или обработку в моделе,
по-правилам, ему запрещено это делать самостоятельно. Он обращается к более профессиональному коллеге.

Петя, знает все принципы работы моделей, он умеет делать сложные выборки, хорошо понимает связи сущностей. Он может помочь Жене
с его проблемой, совместно они строят сложную выборку, даже не сломав и не нагнув базу. Но в какой-то момент они понимают,
что стандартный функционал не может решить их проблему. Нужно модифицировать саму систему (да, такое бывает)

Вася написал уже кучку плагинов и пофиксил несколько багов. Женя и Петя приходят к нему. Вася анализирует ситуацию.
Если решение единоразовое, то он не будет его вносить в систему, он предложит обойти проблему. Если проблема
глобального масштаба, то нужно либо дописать плагин к генератору моделей, либо изменить модели. Он вносит правки.

Таким образом мы отгораживаем разработчиков от чистого SQL и контролируем связи и запросы к базе отвечающие за
выбор данных. Только гуру может внести в процесс изменение и изменить логику выборки данных из базы. При этом
непрофессиональные пользователи "бездумно" оперируют связями без боязни сильно "накосячить".

## <a name="1_3"/> Chapter 1.3. Как достигаются цели?

Небольшое количество атомарных элементов:

* Объект (Entity)
* Набор объектов (Collection)
* Объект условий для действий (Cond)
* Менеджер объектов (Model)

Четко типизированная (константы) структура, не позволит сделать лишнего. В то же время, структура легко изменяется. Можно с легкостью модифицировать практически любые элементы, но это больше присуще архитекторам системы.

В основе лежат простые принципы проектирования базы данных. Нотация, по-которой создается база данных, достаточно хорошо выверена и логична. Многие методы имеют жестко-определенные названия, что позволяет писать функционал и не искать название метода.

Код моделей и методов работы с ней получается легко-читаемым и логичным. Можно посмотреть на переменную и четко сказать, что за модель ее сгенерила и какого типа переменная. Что бы это было, нужно всег-лишь соблюдать нотаци и следовать рекомендациям из этого описания.

Вся основная структура связей/отношений объектов строится автоматически, на основе базы данных. Главное в этой операции - это создать базу данных с правильными ключами и связями. Генератор моделей сделает всю основную работу.

Простота структуры и управления данными - основной принцип. Все операции с данными - очень просты и легки в понимани. Отношения объектов заложены в архитектуру и неподдаются изменению незатрагивая архитектуру приложения. Это накладывает определенные ограничения, но в то же время является преимуством - простота понимания.

## <a name="1_4"/> Chapter 1.4. Основа моделей

В основе всего лежит сущность. Точнее ее содержимое. Любая сущность имеет свои свойства и связанные сущности. В моделях используется многомерный массив, связанные сущности которого помечаются нижним подчеркиванием в начале ключа (поэтому поля в базе с нижним подчеркиванием в начале имени колонки - запрещены).

```php
<?php

$product = array(
    'id' => 12,
    'name' => 'Товар',
    'price' => 12.98,
    'brand_id' => 12,
    '_brand' => array(
        'id' => 12,
        'name' => 'levis'
        '_brand_alias_collection' => array(
            array('id' => 1
                  'name' => 'levi\'s'),
            array('id' => 2
                  'name' => 'levi\'strauses co'),
        )
    )
)
?>
```

Нужно запомнить три следующих утверждения:
1. Поля начинающиеся не с _ - это свойства сущности;
2. Поля, которые начинаются с _ - это связанная сущность или набор сущностей
3. Если поле начинается с _ и заканчивается на _collection - это набор сущностей

Эти утверждения основа, но так же можно встретить связанные данные, которые не являются ни сущностью, ни набором. Это так называемые кешируемые данные или агрегатные.

```php
<?php

$product = array(
    'id' => 12,
    'name' => 'Товар',
    'price' => 12.98,
    'brand_id' => 12,
    '_brand_name' => 'levis',
    '_brand' => array(
        'id' => 12,
        'name' => 'levis'
        '_brand_alias_collection' => array(
            array('id' => 1
                  'name' => 'levi\'s'),
            array('id' => 2
                  'name' => 'levi\'strauses co'),
        )
    )
)
?>
```

Обратите внимание на **_brand_name** - это либо агрегатные данные либо кешируемые, то есть этот параметр может появиться в выборке:

```php
<?php

// Опции для выборки
$cond = ProductModel::getIntance()->getCond()
            ->join(ProductModel::JOINT_BRAND)  // Присоединяем бренд
            ->column(array('*', '_brand_name' => 'brand.name')) // _brand_name - агрегатное свойство

$product = ProductModel::getIntance()->get($cond);
?>
```

Но так же это может появиться в Entity.
```php
<?php

class MyEntity {

    public function getBrandName()
    {
        if ($this->has('_brand_name')) {
            return $this->get('_brand_name');
        } elseif ($this->getBrand()) {
            $this['_brand_name'] = $this->getBrand()->getName();
        }

        return $this->get('_brand_name');
    }
}
?>
```

Такая схема достаточно проста, понятна и логична. Абсолютно, все методы опираются на такую структуру массива.

# <a name="2"/> Chapter 2. Нотация проектирования базы данных

## Введение

Система моделей строилась с учетом персональных предпочтений работы с базой данных. Достаточно большая стабильность проектировки и слаженность в работе комманды достигается за счет введения общих договоренностей. Приведенные ниже, договоренности позволяют недопускать простые ошибки при разработке и проектировании различных сервисов. Мы нарабатываем свои методики, которые используем в повседневной работе.

## Правила наименования табилц и полей

При наименовании полей не используем различных префиксов базы данных и прочей ереси, которая повелась в времен, когда в одну базу данных впирали и форум и чатик и цмс с магазинчиком. Итак, одна полная модель базы - это все таблицы из этой базы.

### Запрет на использование системных переменных в именах полей

Внимание: Наименование полей моделей берется из названия поле базы данных. Настроить псевдонимы - нельзя. Возможности настроить в дальнейших версиях не будет.

Так же крайне не рекомендуется использовать любые названия полей, которые необходимо экранировать: count, as, from и т.д.

### Пропускаемые таблицы

Так уж повелось, но таблицы начинающиеся на "_" или заканчивающиеся на этот символ пропускаются и модели по ним не строятся. Так же не строится модель для таблиц с суффиксом "_index" в дальнейшем суффиксы и префиксы, которые не нужно индексировать можно будет настроить в конфигурационном файле.

### Правила наименования таблиц

При проектировании мы всегда опираемся на базовые сущности. Эти сущности лежат в основе каждого проекта. Например, мы проектируем магазин и хотим сделать теги для магазинов, в этом случае таблицы желательно назвать так:
* product
* tag
* product_tag_link
* product_tag_info (информация по тегу связанному с продуктом)

Но, если вы строите социальную сеть, где теги основа системы, к которым вяжется куча всего, то все должно выглядеть наоборот:

* product
* tag
* tag_product_link
* tag_product_info (информация по продуктом связанному с тегом)

то есть в начало мы ставим базовую сущность на второе место второстепенную, пример актуальной базы:
* product
* tag
* tag_alias
* tag_stat
* tag_info
* comment
* product_info
* product_rubric
* product_rubric_tag_info (таблица для описательных параметров тега для рубрики продукта)
* product_rubric_info
* product_rubric_stat
* product_rubric_index (неиндексируемая моделями таблица: суффикс _index)
* product_product_rubric_link
* product_image
* product_product_image_link
* product_comment_link
* product_tag_link
* и т.д.

# <a name="2"/> Chapter 2. Менеджер моделей Model

## <a name="2_1"/> Chapter 2.1. Добавление данных add

У каждой модели есть метод добавления. В процессе выполнения происходят следующие действия:

* Проверка данных на пустоту, если пусто то вернуть пустой результат
* Применяем [каскад данных](#5_3)
* [Присваиваем значения по-умолчанию](#5_2)
* [Фильтруем данные](#5)
* [Проверяем данные](#6)
* Вставляем данные в базу

Результат метода это объект \Model\Result\Result

# <a name="5"/> Chapter 5. Фильтры

## <a name="5_1"/> Chapter 5.1. Теория фильтрации

!!!ВСЕ ДАННЫЕ ДОЛЖНЫ ФИЛЬТРОВАТЬСЯ!!!

Данные которые мы получаем в моделе, по-умолчанию считаются грязными. Их нужно отмыть, накормить, проверить и поробовать запихать в базу. Дальше расскажу об этапах добавления данных и как можно настроить модель что бы все было по фен-шую.

Представьте, что на входе мы имеем ассоциативный массив с данными, где ключ - это значение поля, а значение собственно само значение этого поля. Прежде чем попасть в базу каждое поле должно быть обработано по следующей схеме:

* **Значения по-умолчанию** - наложение занчений по-умолчанию, кастомим через _setupDefaultsRules_
* **Каскад полей** - если поле пустое, возможно значение можно взять с другого поля, кастомим через _setupFilterCascadeRules_
* **Фильтрация данных** - на каждое поле натравливаются фильтры, которые можно кастомить через методы _setupFilterRules_
* **Проверка данных** - теперь мы все это проверям, кастомить через метод _setupValidatorRules_

### Как проектируем

При создании базы данных мы прописываем поля. При прописывании поле в базе данных, нужно думать, какие данные должны попасть в базу. Другими словами, мы должны отвечать на несколько важных вопросов для каждого поля:

* Что должно быть в поле;
* Что может прийти (прийти может что угодно и еще чуть-чуть);
* Как я буду это фильтровать;

### Пример

В базу данных нужно добавить поле price, помня ошибки прошлого мы делаем его decimal(9, 2), что бы не было проблем с
точностью вычислений.

* Что должно быть в поле:
  * Число с плавающей точкой
* Что может прийти:
  * 1 200 (пробел)
  * 1,200 (число с разделителем)
  * 1.200 (число с разделителем)
  * 1,200.00 (число с разделителем и копейками)
  * 1.200,00 (число с разделителем и копейками)
  * 1,200.000.00 (неправильное число с разделителем и копейками)
  * 1.200,00.00 (неправильное число с разделителем и копейками)
  * $1.200,00.00 dollars (мусор)
* Как будем фильтровать:
  * Подчистим от левых данных;
  * Float наложить точно не получится;
  * Нужно делать разбор числа

*Вывод:* нужно написать свой фильтр, например, \App\Filter\Price

## <a name="5_2"/> Chapter 5.2. Значения по-умолчанию

При добавлении мы учитываем данные по-умолчанию. Это значит что в модельках есть сгенеренный массив в котором мы прописываем, что при создании новой записи, если неопределено поле, то ему нужно присвоить определенное значени. Настраиваются свои значения так:

```php
<?php
public function setupDefaultsRules()
{
    $this->defaultRules['test_field'] => 'Значение по-умолчанию';
}
?>
```

## <a name="5_3"/> Chapter 5.3. Каскад данных при фильтрации

Представьте, что у вас есть сущность в которой есть поля:
* **name** - название чего-то
* **h1** - заголовок
* **title** - название где-то еще
* **meta_title** - название для заголовка браузера
* **slug** - часть от URL

но на входе есть только name, так почему же его нельзя использовать для формирования других полей?!

```php
<?php
public function setupFilterCascadeRules()
{
    // Эти фильтры работают только при добавлении, для фильтров на update используйте updateFilterCascade

    // Если имя прийдет пустое попробовать взять по-очереди из h1, title, meta_title
    $this->addFilterCascadeRules['name'] => array('h1', 'title', 'meta_title');

    $this->addFilterCascadeRules['h1'] => array('name', 'title', 'meta_title');

    $this->addFilterCascadeRules['title'] => array('name', 'h1', 'title');

    $this->addFilterCascadeRules['meta_title'] => array('name', 'h1', 'meta_title');

    $this->addFilterCascadeRules['slug'] => array('name', 'h1', 'title', 'meta_title');
}
?>
```

## <a name="5_4"/> Chapter 5.4. Как добавить свои фильтры в модель

В объекте модели нужно добавить метод:

```php
<?php
    public function setupFilterRules()
    {
        $this->filterRules['field'][] = Filter::getFilterInstance('\App\Filter\MyFilter');
    }
?>
```

## <a name="5_5"/> Chapter 5.5. Как отфильтровать входные данные

```php
<?php

$inputData = array( /** data here **/ );

$filteredInputData = SomeModel::getInstance()->filterOnAdd($inputData);

?>
```

## <a name="5_6"/> Chapter 5.6. Как отфильтровать отдельное поле (filterValue)

```php
<?php
    // Входное значение
    $input = 'some date here';

    $filteredInput = SomeModel::getInstance()->filterValue($input, 'field_name');
?>
```

## <a name="5_7"/> Chapter 5.7. Как запретить фильтрацию

Методы filterOnAdd и filterOnUpdate вторым параметром принимают объект условий, за флаг фильтрации отвечают следующие константы:

```php
<?php
    Cond::FILTER_CASCADE_ON_ADD = true | false; // Разрешить каскад полей в момент фильтрации при добавлении
    Cond::FILTER_CASCADE_ON_UPDATE = true | false; // Разрешить каскад полей в момент фильтрации при изменении

    Cond::FILTER_ON_ADD = true | false; // Разрешить фильтрацию полей при добавлении
    Cond::FILTER_ON_UPDATE = true | false; // Разрешить фильтрацию полей при изменении
?>
```

## <a name="5_8"/> Chapter 5.8. Как работает фильтрация (вид изнутри)

Каждая модель имеет список правил фильтрации для полей:

```php
<?php
    $this->filterRules = array(
        'id' => array(
              Filter::getFilterInstance('\App\Filter\Id')
        ),
        'slug' => array(
              Filter::getFilterInstance('\App\Filter\Slug')
        ),
        'create_date' => array(
              Filter::getFilterInstance('\App\Filter\Date'),
              Filter::getFilterInstance('\Zend\Filter\Null')
        ),
        'modify_date' => array(
              Filter::getFilterInstance('\App\Filter\Date')
        ),
        'status' => array(
              Filter::getFilterInstance('\App\Filter\EnumField')
        )
    );
?>
```

Эти правила инициализируются методом:
```php
<?php
    $this->getFilterRules();
?>
```

После инициализации основных правил фильтрации запускается метод в котором разработчик может управлять текущими правилами фильтрациями:

```php
<?php
    $this->setupFilterRules();
?>
```

На эти данные опираются все методы фильтрации. Дальше при добавлении/измении запускается механизм фильтрации:
* filterOnAdd
* filterOnUpdate

Работают они по одному принципу, различие только в отношении к неопределенным полям (update их пропускает).

**Схема работы этих методов:**

* Применяем каскад данных;
* Получаем правила фильтрации;
* Фильтруем поля;
* Поля для которых нет фильтров, остаются неизменными;

## <a name="5_9"/> Chapter 5.9. Фильтры, которые прописываются автоматически
<table>
<tr>
    <th>Поле в базе</th>
    <th>Что проверяем</th>
    <th>Какие фильтры</th>
</tr>
<tr>
    <td>
        @type - tinyint<br/>
        @type - smallint<br/>
        @type - mediumint<br/>
        @type - int<br/>
        @type - bigint
    </td>
    <td>
        - Число без плавающей точки<br>
    </td>
    <td>
        App\Filter\Int<br/>
        App\Filter\Null (if nullable)<br/>
    </td>
</tr>
<tr>
    <td>
        @type - enum
    </td>
    <td>
        - Латинские буквы, цифры и символ подчеркивания<br/>
    </td>
    <td>
        App\Filter\EnumField<br/>
        App\Filter\Null (if nullable)<br/>
    </td>
</tr>
<tr>
    <td>
        @type - char<br/>
        @type - varchar<br/>
        @type - enum<br/>
        @type - tinyblob<br/>
        @type - tinytext<br/>
        @type - blob<br/>
        @type - text<br/>
        @type - mediumblob<br/>
        @type - mediumtext<br/>
        @type - longblob<br/>
        @type - longtext<br/>
        @type - timestamp
    </td>
    <td>
        - Отсутствие пробельных символов по краям<br/>
    </td>
    <td>
        App\Filter\StringTrim<br/>
        App\Filter\Null (if nullable)<br/>
    </td>
</tr>

<tr>
    <td>
        id<br/>
        _id$
    </td>
    <td>
        - Число без плавающей точки<br>
        - Положительное<br/>
        - Не ноль
    </td>
    <td>
        App\Filter\Id
    </td>
</tr>
<tr>
    <td>
        name[_translate или _alias]$<br/>
        title[_translate или _alias]$<br/>
        h1[_translate или _alias]$<br/>
        meta_title[_translate или _alias]$<br/>
    </td>
    <td>
        - Строка без пробельных симоволов по краям<br/>
        - Без тегов<br/>
        - Без двойных пробельных символов<br/>
        - Начинается с большой буквы<br/>
        - Html Entity заменены на UTF-8 символы
    </td>
    <td>
        App\Filter\Name
    </td>
</tr>
<tr>
    <td>
        <a href="http://en.wikipedia.org/wiki/Clean_URL#Slug" target="_blank">slug</a>
    </td>
    <td>
        - Только латиница и цифры<br/>
        - Остутствуют пробельные символы<br/>
        - Начинается и заканчивается либо на букву, либо на цифру<br/>
        - Теги и недопустимые символы вырезаются<br/>
        - Из русского текста делаем транслит<br/>
        - Ограничен длинной в 255 символов
    </td>
    <td>
        App\Filter\Slug
    </td>
</tr>
<tr>
    <td>
        description<br/>
        _description<br/>
        text<br/>
        _text<br/>
    </td>
    <td>
        - Накладывается вырезатель опасных тего<br/>
        - Разрешены все теги кроме опасных<br/>
        - Накладывается типограф
    </td>
    <td>
        App\Filter\Text
    </td>
</tr>
<tr>
    <td>
        url<br/>
        _url$
    </td>
    <td>
        - Валидные данные url<br/>
        - Запрещены теги<br/>
        - Запрещены символы не подходящие для url<br/>
        - Не хранится schema URL
    </td>
    <td>
        App\Filter\Url
    </td>
</tr>
<tr>
    <td>
        level<br/>
        pos
    </td>
    <td>
        - Только число<br/>
        - Только целое<br/>
        - Только положительное
    </td>
    <td>
        App\Filter\Abs
    </td>
</tr>
<tr>
    <td>
        email<br/>
        _email$
    </td>
    <td>
        - Символы разрешенные в E-Mail<br/>
    </td>
    <td>
        App\Filter\Email
    </td>
</tr>
<tr>
    <td>
        price<br/>
        _price$
    </td>
    <td>
        - На выходе float число
    </td>
    <td>
        App\Filter\Price
    </td>
</tr>
<tr>
    <td>
        ^is_
    </td>
    <td>
        - Может содержать только <b>y</b> или <b>n</b>
    </td>
    <td>
        App\Filter\IsFlag
    </td>
</tr>
<tr>
    <td>
        _hash$
    </td>
    <td>
        - Может содержать только <b>[A-H0-9]</b> только в верхнем регистре<br/>
        - Максимальная длинна 40 символов
    </td>
    <td>
        App\Filter\Hash
    </td>
</tr>
<tr>
    <td>
        _stem$
    </td>
    <td>
        - Стем слов<br/>
    </td>
    <td>
        App\Filter\Stem
    </td>
</tr>
<tr>
    <td>
        _count$
    </td>
    <td>
        - На выходе int число (положительное)
    </td>
    <td>
        App\Filter\Abs<br/>
        App\Filter\Abs
    </td>
</tr>
<tr>
    <td>
        _date$
    </td>
    <td>
        - На выходе дата в формате Y-m-d H:i:s
    </td>
    <td>
        App\Filter\Date
    </td>
</tr>

</table>

## <a name="5_10"/> Chapter 5.10. Список существующих фильтров
<table>
<tr>
    <th>Класс фильтра</th>
    <th>Опции</th>
    <th>Что делает</th>
</tr>
<tr>
    <td>App\Filter\Abs</td>
    <td>нет</td>
    <td>Делает значение абсолютным</td>
</tr>
<tr>
    <td>App\Filter\Date</td>
    <td>нет</td>
    <td>Пытается создать дату в формате Y-m-d H:i:s из разных данных</td>
</tr>
<tr>
    <td>App\Filter\Email</td>
    <td>нет</td>
    <td>Удаляет символы запрещенные в E-Mail</td>
</tr>
<tr>
    <td>App\Filter\EntityDecode</td>
    <td>нет</td>
    <td>Заменяет HTML-entities на обычные символы</td>
</tr>
<tr>
    <td>App\Filter\EnunField</td>
    <td>нет</td>
    <td>Оставляет символы разрешенные для значений enum-полей</td>
</tr>
<tr>
    <td>App\Filter\Float</td>
    <td>нет</td>
    <td>Приводит значение к Float</td>
</tr>
<tr>
    <td>App\Filter\Hash</td>
    <td>нет</td>
    <td>Удаляет символы не относящиеся к hash, оставляет первые 40 символов</td>
</tr>
<tr>
    <td>App\Filter\Id</td>
    <td>нет</td>
    <td>Приводит к абсолютному числу</td>
</tr>
<tr>
    <td>App\Filter\IsFlag</td>
    <td>нет</td>
    <td>Очищает все что не <b>Y</b> и не <b>N</b></td>
</tr>
<tr>
    <td>App\Filter\Md5</td>
    <td>нет</td>
    <td>Делает из строки md5</td>
</tr>
<tr>
    <td>App\Filter\Name</td>
    <td>нет</td>
    <td>Фильтрует имя, вырезает  теги, лишнее пробелы и тд</td>
</tr>
<tr>
    <td>App\Filter\PlainText</td>
    <td>нет</td>
    <td>Удаляет теги и немного подчищает. Декодит HTML-Entity</td>
</tr>
<tr>
    <td>App\Filter\Price</td>
    <td>нет</td>
    <td>Из мусора умеет делать цену товара, например</td>
</tr>
<tr>
    <td>App\Filter\Slug</td>
    <td>нет</td>
    <td>Все что не английский - в транслит, заменяет пробелы на -, оставляет символы разрещенные для использования в URL</td>
</tr>
<tr>
    <td>App\Filter\Stem</td>
    <td>нет</td>
    <td>Берет основания от всех слов</td>
</tr>
<tr>
    <td>App\Filter\StemHash</td>
    <td>нет</td>
    <td>Делает hash текста с использованием stem</td>
</tr>
<tr>
    <td>App\Filter\Stopword</td>
    <td>нет</td>
    <td>Фильтрует нежелательные слова</td>
</tr>
<tr>
    <td>App\Filter\StringTrim</td>
    <td>нет</td>
    <td>Тупо, trim</td>
</tr>
<tr>
    <td>App\Filter\Truncate</td>
    <td>
        <b>length</b> = 80 // длина строки<br/>
        <b>etc</b>    = '&amp;#133;' // что добавить в конце обрезанной строки<br/>
        <b>break_words</b>    = true | false; // разрешить "рвать" слова<br/>
        <b>middle</b>     = true | false; // сделать обрезку текста по-центру
    </td>
    <td>Обрезка текста</td>
</tr>
<tr>
    <td>App\Filter\Truncate40</td>
    <td>нет</td>
    <td>Взять первые 40 символов</td>
</tr>
<tr>
    <td>App\Filter\Truncate128</td>
    <td>нет</td>
    <td>Взять первые 128 символов</td>
</tr>
<tr>
    <td>App\Filter\Truncate255</td>
    <td>нет</td>
    <td>Взять первые 255 символов</td>
</tr>
<tr>
    <td>App\Filter\Ucfirst</td>
    <td>нет</td>
    <td>Делает первый символ в верхнем регистре, остальные в нижнем</td>
</tr>
<tr>
    <td>App\Filter\Url</td>
    <td>все сложно, смотри код</td>
    <td>Фильтрует URL</td>
</tr>
<tr>
    <td>App\Filter\Xml</td>
    <td>нет</td>
    <td>Чистит код от нечистой силы, что ломает XML</td>
</tr>

</table>

# <a name="6"/> Chapter 6. Валидаторы

## <a name="6_1"/> Chapter 6.1. Теория валидации?

Все данные которые попадают в базу данных должны быть обязательно проверены. Если данные не проверять перед вставкой, можно попасть с XSS или просто упадет приложение, так как база не ожидает таких данных.

## <a name="6_2"/> Chapter 6.2. Как добавить свои валидаторы в модель?

В объекте модели нужно добавить метод:

```php
<?php
    public function setupValidatorRules()
    {
        // В эту переменную складываем валидаторы, которые будут работать при добавлении
        // $this->validatorRules['required'];

        // В эту переменную складываем валидаторы, которые будут работать при изменении
        // $this->validatorRules['not_required'];;

        $this->validatorRules['not_required']['field'][] = Validator::getValidatorInstance('\App\Validator\MyValidator');
    }
?>
```

## <a name="6_3"/> Chapter 6.3. Как проверить отдельное поле (validateValue)

```php
<?php
    // Входное значение
    $input = 'some date here';

    // ВНИМАНИЕ!!! Валидация поля работает по методу когда не проверяется наличие поля, то есть как у update
    // $this->validatorRules
    /** @var $validator boolean|Validator **/
    $validator = SomeModel::getInstance()->validateValue($input, 'field_name');

    // Работать так
    if ($validator !== true) {
        // Ошибка
        $messages = $validtor->getMessages();
    }
?>
```

## <a name="6_4"/> Chapter 6.4. Схема инициализации работы валидатора

```php
<?php
    /**
     * Самый-самый родитель
     */
    class AbstractModel
    {
        public function getValidatorRules($reqiured)
        {
            $this->initValidatorRules();
        }
    }

    /**
     * Самый-самый родитель
     */
    class AbstractGeneratedModel
    {
        public function initValidatorRules($reqiured)
        {
            /** тут правила сгенеренные генератором **/
            $this->setupValidatorRules();
        }
    }

    /**
     * Модель куда разработчик вносит изменения
     */
    class Model
    {
        public function setupValidatorRules($reqiured)
        {
            /** тут правила прописанные пользователем **/
        }
    }
?>
```

# <a name="7"/> Chapter 7. Объект результата выполнения операции (Result)

Объект результата прост до безобразия:
- result - результат
- errors - ошибки, которые возникли во-время выполнения
- childs - дети, у каждой оперции может быть много вложенных операций

Некоторые операции, требуют в ответе вернуть не только результат, но и валидатор и другие параметры.
Схема работы очень проста, он фиксирует текущий результат, а так же вложенные (например, при импорте данных) Объект имеет вложенную структуру. То есть внутри одного Result может содержать несколько других Result

Ниже перечень основных методов по работе с Result

```php
<?php

$result = Model::getInstance()->add(/** data **/);

// При вставке не было ошибок
if ($result->isValid()) {
    // do something
}

// Идентификатор добавленной записи/записей (может быть массивом)
$insertId = $result->getResult();

// Получить перечень ошибок с учетом вложенных результатов
$errorList = $result->getErrorList();

?>
```

# <a name="8"/> Chapter 8. Объект условий Cond

## <a name="8_1"/> Chapter 8.1. Общее описание

Объект условий - это объект простого типа, который хранит в себе какие связи нужно подключить к выборке и как отсортировать и отфильтровать данные.

**Так же объект условий содержит внутри себя следующие важные данные:**

* Имя сущности для которой создан
* Имя Entity - нужна что бы сообщить модели, какого типа данные мы ожидаем
* Имя Collection - нужна что бы сообщить модели, какого типа данные мы ожидаем

## <a name="8_2"/> Chapter 8.2. Method `from`

Говорит из какой таблицы будет производиться выборка.

**Синтаксис:**

```php
Cond::init()->from('table_name'); // SELECT FROM table_name
Cond::init()->from(array('table_alias' => 'table_name')); // SELECT FROM table_name as table_alias
```
